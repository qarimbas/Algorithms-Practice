//Red-Black Tree (RBT) is a BST//we will always have h = O(lg n) for an RBT//Not every BST can be colored to form a RBT//RBT properties:/*1. Every node is red or black2. The root is black.3. Every leaf node is black(automatically guaranteed by using the	black RBT leaf nodes as the leaves).4. A red node always has two black children.5. Every path from the root to a leaf has the same number of black	nodes.*/RBT_Insert(T, x) { // T: the tree, x: a new node to be inserted	color[x] = RED; // the new node will be red	BST_Insert(T, x); // insert as if we were using an ordinary BST	FixColoring(T, x); // fix the “red-red” coloring problem if exists}/* - BST_Insert needs O(h) time. - FixColoring needs O(h) time. - Therefore, RBT_Insert needs O(h) time. - For RBTs, h=O(lg n). - Hence, RBT_Insert needs O(lg n) time.*/RBT_Rank(T, x) { // T: the tree, x: a node	rank = CountNodes(left[x]) + 1; // # of elements in left subtree of x + x itself	y = parent[x];	z = x; // y -> z is an edge in the path from x to root	while (y != NULL) { // until we reach to the root		if (right[y] == z) { // if x is in the right subtree of y		// then all the keys in the left subtree of y, and the key at y		// are smaller than key[ x ]			rank = rank + CountNodes(left[y]) + 1;		}		z = y;		y = parent[z]; // go one level up in the tree	}	return rank;}CountNodes(x) { // x: a node	if (x == RBT_Leaf) // the special RBT leaf node we have used		return 0;	// otherwise find # of nodes in the left and right subtree	return (1 + CountNodes(left[x]) + CountNodes(right[x]));}AugmentedRBT_Rank(T, x) { // T: the tree, x: a node	rank = size(left[x]) + 1; // # of elements in left subtree of x & x itself	y = parent[x];	z = x; // y -> z is an edge in the path from x to root	while (y != NULL) { // until we reach to the root		if (right[y] == z) { // if x is in the right subtree of y		// then all the keys in the left subtree of y, and the key at y		// are smaller than key[ x ]			rank = rank + size(left[y]) + 1;		}		z = y;		y = parent[z]; // go one level up in the tree	}	return rank;}AugmentedRBT_Select(x, i) { // x: a node, i: looking for ith order statistics// we assume size(x) ≥ i	left& self = size(left[x]) + 1; // # of elements in left subtree of x & x itself	if (i == left & self) // case 1		return (key[x]);	if (i < left & self) // case 2		return (AugmentedRBT_Select(left[x], i));	//case 3	return (AugmentedRBT_Select(right[x], i - left & self));}RBT_Insert(T, x) { // T: the tree, x: a new node to be inserted	color[x] = RED; // the new node will be red	BST_Insert(T, x); // insert as if we were using an ordinary BST	FixColoring(T, x); // fix the “red-red” coloring problem if exists}AugmentedRBT_Insert(T, x) { // T: the tree, x: a new node to be inserted	color[x] = RED; // the new node will be red	AugmentedBST_Insert(T, x); // insert as if we were using an ordinary BST	AugmentedFixColoring(T, x); // fix the “red-red” coloring problem if exists}AugmentedBST_Insert(T, x) { // T: the tree, x: a new node to be inserted	BST_Insert(T, x); // insert as if it is normal BST	size[x] = 1; // assign the size field of x	// Any node along the path from the root to x will 	// have one more element under it. Increment their size field by 1.	tmp = parent[x];	while (tmp != NULL) {		size[tmp] = size[tmp] + 1;		tmp = parent[tmp];	}IntervalRBT_Insert(T, x) { // T: the tree, x: a new interval node to be inserted	color[x] = RED; // the new node will be red	IntervalBST_Insert(T, x); // insert as if we were using an ordinary BST	IntervalFixColoring(T, x); // fix the “red-red” coloring problem if exists	}IntervalRBT_Insert(T, x) { // T: the tree, x: a new interval node to be inserted	 BST_Insert(T, x); // insert as if it were normal BST	 max[x] = high[x]; // assign the max field of x (no internal nodes below)	 // Any node along the path from the root to x that has a max 	 // field smaller than high[ x ] should be fixed.	 tmp = parent[x];	 while (tmp != NULL) {		 if (max[tmp] < high[x]) max[tmp] = high[x];		 tmp = parent[tmp];	 }IntervalRBT_Insert(T, x) { // T: the tree, x: a new interval node to be inserted		 color[x] = RED; // the new node will be red		 IntervalBST_Insert(T, x); // insert as if we were using an ordinary BST		 IntervalFixColoring(T, x); // fix the “red-red” coloring problem if exists	 }IntervalRBT_Search(T, l, h) { // T: the tree, [l, h]: the search interval	x = root[T]; // start from the root the tree	while ((x != NULL) and ([l, h] does not intersect with[low[x], high[x]])) {		if ((left[x] != NULL) and max[left[x]] ≥ l) )		x = left[x]; // if an overlapping interval exists, it is in the left subtree		else			x = right[x]; // if an overlapping interval exists, it is in the right subtree	}	return x;}